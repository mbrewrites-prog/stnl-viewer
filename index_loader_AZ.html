<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <title>STNL Viewer — A–Z Lemma Loader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    h1 { margin-top: 0; }
    .controls { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
    .modes { grid-column: 1 / -1; display: flex; gap: 16px; font-size: 14px; color: #333; }
    input[type="text"] { padding: 8px 10px; font-size: 16px; }
    button { padding: 8px 12px; font-size: 14px; cursor: pointer; }
    .result { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-top: 12px; }
    .head { font-weight: 700; }
    .pos { display: inline-block; margin-left: 8px; font-size: 12px; padding: 1px 6px; border: 1px solid #e5e5e5; border-radius: 999px; background: #f8f8f8; }
    .content p { margin: 8px 0; }
    .content { white-space: normal; } /* full-width sentences */
    .note { color: #666; font-size: 12px; }
    .related { margin-top: 16px; font-size: 14px; }
    .chip { display: inline-block; margin: 4px 6px 0 0; padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; cursor: pointer; }
    .small { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <h1>STNL Viewer — A–Z Lemma Loader</h1>
  <p class="note">Exact lemma-definitie, voor <strong>alle</strong> woorden. Alleen het eigen betekenisblok. Zinnen lopen over de hele marge; na elke punt komt een spatie (UI-weergave). Genummerde betekenissen worden onder elkaar gezet.</p>

  <div class="controls">
    <input id="q" type="text" placeholder="Lemma (bijv. abi, ai, aleisi, anansi, ...)" />
    <div>
      <button id="btnSearch">Zoek</button>
      <button id="btnClear">Wissen</button>
    </div>
    <div class="modes">
      <label><input type="radio" name="mode" value="exact" checked> Lemma exact</label>
      <label><input type="radio" name="mode" value="starts"> Lemma begint met</label>
    </div>
  </div>

  <div id="out"></div>
  <div class="small">Tip: als een lemma niet wordt gevonden, controleer de spelling en gebruik 'Begint met' om varianten te vinden.</div>

  <script>
    const GROUP_FILES = {
      a: 'STNL_lemma_blocks_A.json',
      b: 'STNL_lemma_blocks_B.json',
      c: 'STNL_lemma_blocks_C.json',
      d: 'STNL_lemma_blocks_D.json',
      e: 'STNL_lemma_blocks_E.json',
      f: 'STNL_lemma_blocks_F.json',
      g: 'STNL_lemma_blocks_G.json',
      h: 'STNL_lemma_blocks_H.json',
      i: 'STNL_lemma_blocks_I.json',
      j: 'STNL_lemma_blocks_J.json',
      k: 'STNL_lemma_blocks_K.json',
      l: 'STNL_lemma_blocks_L.json',
      m: 'STNL_lemma_blocks_M.json',
      n: 'STNL_lemma_blocks_N.json',
      o: 'STNL_lemma_blocks_O.json',
      p: 'STNL_lemma_blocks_P.json',
      q: 'STNL_lemma_blocks_Q.json',
      r: 'STNL_lemma_blocks_R.json',
      s: 'STNL_lemma_blocks_S.json',
      t: 'STNL_lemma_blocks_T.json',
      u: 'STNL_lemma_blocks_U.json',
      v: 'STNL_lemma_blocks_V.json',
      w: 'STNL_lemma_blocks_W.json',
      x: 'STNL_lemma_blocks_X.json',
      y: 'STNL_lemma_blocks_Y.json',
      z: 'STNL_lemma_blocks_Z.json',
      other: 'STNL_lemma_blocks_OTHER.json'
    };

    const cache = new Map();

    async function loadGroup(letter) {
      const key = GROUP_FILES[letter] ? letter : 'other';
      if (cache.has(key)) return cache.get(key);
      const file = GROUP_FILES[key];
      const res = await fetch(file);
      if (!res.ok) return [];
      const data = await res.json();
      cache.set(key, data);
      return data;
    }

    function normalizeSpacing(s) {
      if (!s) return '';
      // Collapse newlines to spaces (full-width sentences)
      s = s.replace(/[\r\n]+/g, ' ');
      // Ensure a space after periods if followed by a non-space
      s = s.replace(/\.(\S)/g, '. $1');
      // Collapse multiple spaces
      s = s.replace(/\s{2,}/g, ' ');
      return s.trim();
    }

    function splitSenses(text) {
      const t = normalizeSpacing(text);
      // Mark numbered senses: "1)" "2)" ... at word boundaries
      const marked = t.replace(/(^|\s)(\d+)\)\s*/g, (m, pre, num) => `${pre}@@SENSE_${num}@@ `);
      const parts = marked.split('@@').filter(x => x);
      const senses = [];
      for (let i=0; i<parts.length; i++) {
        const part = parts[i];
        if (part.startsWith('SENSE_')) {
          // Next chunk is the content until next marker or end
          const num = part.replace('SENSE_','').trim();
          let content = '';
          // Consume following piece if exists
          if (i+1 < parts.length) {
            content = parts[i+1];
            i++;
          }
          senses.push({num, text: content.trim()});
        }
      }
      // If no senses found, return as single paragraph
      if (senses.length === 0 && t) {
        return [{num: null, text: t}];
      }
      return senses;
    }

    function renderBlock(b) {
      const container = document.createElement('div');
      container.className = 'result';
      const head = document.createElement('div');
      head.className = 'head';
      head.innerHTML = `${b.lemma} <span class="pos">${b.pos}</span>`;
      const contentDiv = document.createElement('div');
      contentDiv.className = 'content';
      const senses = splitSenses(b.content || '');
      if (senses.length > 1 || (senses.length === 1 && senses[0].num)) {
        const ol = document.createElement('ol');
        for (const s of senses) {
          const li = document.createElement('li');
          li.textContent = s.text;
          ol.appendChild(li);
        }
        contentDiv.appendChild(ol);
      } else {
        const p = document.createElement('p');
        p.textContent = senses[0] ? senses[0].text : '';
        contentDiv.appendChild(p);
      }
      container.appendChild(head);
      container.appendChild(contentDiv);
      return container;
    }

    async function doSearch() {
      const q = document.getElementById('q').value.trim();
      const mode = (document.querySelector('input[name="mode"]:checked') || {}).value || 'exact';
      const out = document.getElementById('out');
      out.innerHTML = '';
      if (!q) return;
      const first = q[0].toLowerCase();
      const data = await loadGroup(GROUP_FILES[first] ? first : 'other');
      const L = q.toLowerCase();
      const exact = data.filter(b => (b.lemma || '').toLowerCase() === L);
      const starts = data.filter(b => (b.lemma || '').toLowerCase().startsWith(L) && (b.lemma || '').toLowerCase() !== L);

      if (mode === 'exact' && exact.length) {
        for (const b of exact) out.appendChild(renderBlock(b));
      } else if (mode === 'starts') {
        for (const b of starts.slice(0, 50)) out.appendChild(renderBlock(b));
      } else if (!exact.length) {
        out.innerHTML = '<p>Geen exact lemma gevonden. Probeer "Begint met".</p>';
      }
    }

    document.getElementById('btnSearch').onclick = doSearch;
    document.getElementById('btnClear').onclick = () => {
      document.getElementById('q').value = '';
      document.getElementById('out').innerHTML = '';
      document.getElementById('q').focus();
    };
  </script>
</body>
</html>
